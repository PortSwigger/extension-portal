name: Process created issue

on:
  issues:
    types: [opened]

permissions:
  issues: write
  contents: read

jobs:
  extract-issue-details:
    if: |
      contains(github.event.issue.body, 'template:01-submit-extension') ||
      contains(github.event.issue.body, 'template:02-submit-update')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      url: ${{ steps.extract.outputs.url }}
      version_number: ${{ steps.extract.outputs.version_number }}
      author: ${{ steps.extract.outputs.author }}
      title: ${{ steps.extract.outputs.title }}
      error_message: ${{ steps.extract.outputs.error_message }}
      product_compatibility: ${{ steps.extract.outputs.product_compatibility }}

    steps:
      - name: Extract submission details
        id: extract
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            try {
              const body = context.payload.issue.body || '';
              const EMPTY_RESPONSE = '_No response_';

              // Utility functions
              const sanitizeText = (text, maxLength = 200) => {
                if (!text) return '';
                return text
                  .replace(/[<>\"'`]/g, '')
                  .replace(/[\r\n\t]/g, ' ')
                  .replace(/[^\x20-\x7E]/g, '')
                  .substring(0, maxLength)
                  .trim();
              };

              const validateVersion = (version) => {
                if (!version) return null;
                const trimmed = version.trim();
                if (!/^[0-9a-zA-Z.-]+$/.test(trimmed) || trimmed.length > 50) {
                  throw new Error(`Invalid version format: "${trimmed}". Only alphanumeric characters, dots, and hyphens are allowed.`);
                }
                return trimmed;
              };

              const extractField = (pattern, defaultValue = null) => {
                const match = body.match(pattern);
                return match ? match[1].trim() : defaultValue;
              };

              const isFieldEmpty = (value) => !value || value === EMPTY_RESPONSE;

              const missingFields = [];

              // Extract common fields
              const versionNumber = validateVersion(extractField(/### Version number\s+([^\n]+)/));
              if (isFieldEmpty(versionNumber)) missingFields.push('Version number');
              
              const title = sanitizeText(context.payload.issue.title, 200);
              const author = sanitizeText(extractField(/### Author display name\s+([^\n]+)/), 100);

              core.setOutput('version_number', versionNumber);
              core.setOutput('title', title);
              core.setOutput('author', author);

              let url;
              if (body.includes('template:01-submit-extension')) {
                url = extractField(/### Extension URL\s+([^\s]+)/);
                if (isFieldEmpty(url)) missingFields.push('Extension URL');
                if (isFieldEmpty(author)) missingFields.push('Author display name');
              } else if (body.includes('template:02-submit-update')) {
                url = extractField(/### Pull request URL\s+([^\s]+)/);
                if (isFieldEmpty(url)) missingFields.push('Pull request URL');
                // Author is optional for updates
              }

              core.setOutput('url', url);

              // Extract product compatibility labels
              const compatibilityOptions = ['Community', 'DAST', 'Burp AI'];
              const productCompatibility = compatibilityOptions.filter(label =>
                body.includes(`- [x] ${label}`) || body.includes(`- [X] ${label}`)
              );
              core.setOutput('product_compatibility', JSON.stringify(productCompatibility));

              if (missingFields.length > 0) {
                throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
              }
            } catch (error) {
              core.setOutput('error_message', error.message);
              throw error;
            }

  submit-extension:
    needs: extract-issue-details
    if: |
      always() &&
      contains(github.event.issue.body, 'template:01-submit-extension')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      zoom_payload: ${{ steps.prepare_zoom.outputs.payload }}
      template_key: ${{ steps.prepare_comment.outputs.template_key }}
      error_message: ${{ steps.prepare_comment.outputs.error_message }}
      should_close: ${{ steps.prepare_comment.outputs.should_close }}
      has_comment: ${{ steps.prepare_comment.outputs.has_comment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Apply product compatibility labels
        if: needs.extract-issue-details.outputs.product_compatibility != ''
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            try {
              const compatibilityData = process.env.PRODUCT_COMPATIBILITY || '[]';
              const labels = JSON.parse(compatibilityData);

              if (Array.isArray(labels) && labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labels
                });
                core.info(`Applied product compatibility labels: ${labels.join(', ')}`);
              } else {
                core.info('No additional product compatibility labels selected');
              }
            } catch (error) {
              core.warning(`Failed to apply product compatibility labels: ${error.message}`);
            }
        env:
          PRODUCT_COMPATIBILITY: ${{ needs.extract-issue-details.outputs.product_compatibility }}

      - name: Validate GitHub repository URL
        id: validate_url
        if: needs.extract-issue-details.outputs.error_message == ''
        continue-on-error: true
        run: |
          python3 .github/scripts/validate_repo_url.py "${{ needs.extract-issue-details.outputs.url }}" new-submission

      - name: Verify repository exists and is not a fork
        id: validate_repo
        if: needs.extract-issue-details.outputs.error_message == '' && steps.validate_url.outcome == 'success'
        continue-on-error: true
        run: |
          python3 .github/scripts/validate_repo.py
        env:
          URL: ${{ needs.extract-issue-details.outputs.url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Identify extension language
        id: extension_language
        if: needs.extract-issue-details.outputs.error_message == '' && steps.validate_repo.outcome == 'success'
        continue-on-error: true
        run: |
          python3 .github/scripts/detect_language.py "${{ needs.extract-issue-details.outputs.url }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Java
        if: steps.extension_language.outputs.language == 'Java'
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: 21

      - name: Checkout extension repository
        uses: actions/checkout@v4
        if: steps.extension_language.outputs.language == 'Java'
        with:
          repository: '${{ steps.validate_repo.outputs.owner }}/${{ steps.validate_repo.outputs.repo }}'
          path: 'extension-repo'

      - name: Determine build platform
        id: build_platform
        if: steps.extension_language.outputs.language == 'Java'
        working-directory: extension-repo
        continue-on-error: true
        run: |
          if [[ -f "pom.xml" ]]; then
            echo "BUILD_SYSTEM=Maven" >> $GITHUB_ENV
            echo "build_system=Maven" >> $GITHUB_OUTPUT
          elif [[ -f "build.gradle" || -f "build.gradle.kts" ]]; then
            echo "BUILD_SYSTEM=Gradle" >> $GITHUB_ENV
            echo "build_system=Gradle" >> $GITHUB_OUTPUT
          else
            echo "ERROR: Unable to detect Java build system (no pom.xml or build.gradle found)"
            echo "Please provide a custom build command or ensure your project uses Maven or Gradle"
            exit 1
          fi

      - name: Run Gradle
        if: steps.build_platform.outputs.build_system == 'Gradle'
        working-directory: extension-repo
        continue-on-error: true
        run: |
          chmod +x gradlew || { echo "ERROR: Failed to make gradlew executable"; exit 1; }

          if [ -d build ]; then
            ./gradlew clean build || { echo "ERROR: Gradle clean build failed"; exit 1; }
          else
            ./gradlew build || { echo "ERROR: Gradle build failed"; exit 1; }
          fi

      - name: Run Maven
        if: steps.build_platform.outputs.build_system == 'Maven'
        working-directory: extension-repo
        continue-on-error: true
        run: |
          mvn clean package || { echo "ERROR: Maven clean package failed"; exit 1; }

      - name: Create Jira ticket
        id: create_jira
        if: needs.extract-issue-details.outputs.error_message == '' && steps.validate_url.outcome == 'success' && steps.validate_repo.outcome == 'success'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const title = process.env.TITLE;
            const issueUrl = context.payload.issue.html_url;

            const jiraAuth = Buffer.from(`${process.env.JIRA_USER_EMAIL}:${process.env.JIRA_API_TOKEN}`).toString('base64');
            const jiraHeaders = { 'Authorization': `Basic ${jiraAuth}`, 'Content-Type': 'application/json' };

            // Create Jira ticket
            const createResponse = await fetch(`${process.env.JIRA_BASE_URL}/rest/api/3/issue`, {
              method: 'POST',
              headers: jiraHeaders,
              body: JSON.stringify({
                fields: {
                  project: { key: "BAPP" },
                  summary: title,
                  issuetype: { id: "10278" },
                  customfield_10932: process.env.NORMALIZED_URL,
                  customfield_12030: "extensions-build-pipeline"
                }
              })
            });

            if (!createResponse.ok) {
              const errorText = await createResponse.text();
              core.warning(`Jira API error: ${createResponse.status} - ${errorText}`);

              throw new Error(`Failed to create Jira ticket: ${createResponse.status}`);
            }

            const jiraIssue = await createResponse.json();
            const jiraKey = jiraIssue.key;
            core.debug(`Created Jira ticket: ${jiraKey}`);

            // Add remote link to GitHub issue
            const linkResponse = await fetch(`${process.env.JIRA_BASE_URL}/rest/api/3/issue/${jiraKey}/remotelink`, {
              method: 'POST',
              headers: jiraHeaders,
              body: JSON.stringify({
                object: {
                  url: issueUrl,
                  title: `GitHub Issue #${context.issue.number}: ${title}`,
                  icon: { url16x16: "https://github.githubassets.com/favicons/favicon.svg", title: "GitHub" }
                }
              })
            });

            if (!linkResponse.ok) {
              const linkErrorText = await linkResponse.text();
              core.warning(`Failed to add remote link: ${linkResponse.status} - ${linkErrorText}`);
            } else {
              core.debug('Added remote link to Jira ticket');
            }

            core.setOutput('jira_url', `${process.env.JIRA_BASE_URL}/browse/${jiraKey}`);
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          NORMALIZED_URL: ${{ steps.validate_repo.outputs.normalized_url }}
          TITLE: ${{ needs.extract-issue-details.outputs.title }}

      - name: Generate GitHub App token
        id: generate_token
        if: steps.create_jira.outcome == 'success'
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROJECT_ACCESS_APP_ID }}
          private-key: ${{ secrets.PROJECT_ACCESS_PRIVATE_KEY }}
          repositories: extension-portal-internal

      - name: Convert product compatibility format
        id: convert_products
        if: steps.generate_token.outcome == 'success'
        continue-on-error: true
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const compatibilityData = process.env.PRODUCT_COMPATIBILITY || '[]';
            const labels = JSON.parse(compatibilityData);

            // Map display names to lowercase format expected by review workflow
            const mapping = {
              'Community': 'community',
              'DAST': 'dast',
              'Burp AI': 'burpai'
            };

            const convertedProducts = labels
              .map(label => mapping[label])
              .filter(Boolean)
              .join(',');

            core.setOutput('products', convertedProducts);
            core.info(`Converted products: ${convertedProducts}`);
        env:
          PRODUCT_COMPATIBILITY: ${{ needs.extract-issue-details.outputs.product_compatibility }}

      - name: Trigger review workflow
        id: review_workflow
        if: steps.convert_products.outcome == 'success'
        continue-on-error: true
        env:
          OWNER: PortSwigger
          REPO: extension-portal-internal
          WORKFLOW_FILE: sanitize-and-analyze.yml
          REF: main
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
          EXTENSION_NAME: ${{ needs.extract-issue-details.outputs.title }}
          TARGET_REPO_URL: ${{ needs.extract-issue-details.outputs.url }}
          COMPATIBLE_PRODUCTS: ${{ steps.convert_products.outputs.products }}
        run: |
          # Build JSON payload
          payload=$(cat <<EOF
          {
            "ref": "$REF",
            "inputs": {
              "extension_name": "$EXTENSION_NAME",
              "target_repo_url": "$TARGET_REPO_URL",
              "compatible_products": "$COMPATIBLE_PRODUCTS"
            }
          }
          EOF
          )

          curl -sS -f -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            https://api.github.com/repos/$OWNER/$REPO/actions/workflows/$WORKFLOW_FILE/dispatches \
            -d "$payload"

          echo "Workflow dispatch triggered successfully"

      - name: Prepare comment data
        id: prepare_comment
        if: always()
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const extractError = process.env.EXTRACT_ERROR || '';
            const validateUrlOutcome = process.env.VALIDATE_URL_OUTCOME || 'skipped';
            const validateUrlError = process.env.VALIDATE_URL_ERROR || '';
            const validateRepoOutcome = process.env.VALIDATE_REPO_OUTCOME || 'skipped';
            const validateRepoError = process.env.VALIDATE_REPO_ERROR || '';
            const createJiraOutcome = process.env.CREATE_JIRA_OUTCOME || 'skipped';

            core.info(`Extract error: "${extractError}"`);
            core.info(`Validate URL outcome: "${validateUrlOutcome}"`);
            core.info(`Validate repo outcome: "${validateRepoOutcome}"`);
            core.info(`Create Jira outcome: "${createJiraOutcome}"`);

            // Job is successful if there are no errors and all outcomes are success
            const jobSuccess = !extractError && validateUrlOutcome === 'success' && validateRepoOutcome === 'success' && createJiraOutcome === 'success';

            core.info(`Job success: ${jobSuccess}`);

            let templateKey;
            let errorMessage = '';
            let shouldClose = false;

            if (jobSuccess) {
              templateKey = 'extension-submission.success';
            } else {
              let specificError = extractError;

              if (!specificError && validateUrlOutcome === 'failure') {
                specificError = validateUrlError || 'Invalid GitHub repository URL format.';
              }

              if (!specificError && validateRepoOutcome === 'failure') {
                specificError = validateRepoError || 'Repository validation failed. The repository may be a fork or not accessible.';
              }

              if (!specificError && createJiraOutcome === 'failure') {
                specificError = 'Failed to create ticket. Please contact [bapps@portswigger.net](mailto:bapps@portswigger.net) for assistance.';
              }

              templateKey = specificError
                ? 'extension-submission.failure-specific'
                : 'extension-submission.failure-generic';
              errorMessage = specificError || '';
              shouldClose = true;
            }

            core.info(`Template key: ${templateKey}`);
            core.info(`Error message: ${errorMessage}`);
            core.info(`Should close: ${shouldClose}`);

            core.setOutput('template_key', templateKey);
            core.setOutput('error_message', errorMessage);
            core.setOutput('should_close', shouldClose.toString());
            core.setOutput('has_comment', 'true');
        env:
          EXTRACT_ERROR: ${{ needs.extract-issue-details.outputs.error_message }}
          VALIDATE_URL_OUTCOME: ${{ steps.validate_url.outcome }}
          VALIDATE_URL_ERROR: ${{ steps.validate_url.outputs.error_message || '' }}
          VALIDATE_REPO_OUTCOME: ${{ steps.validate_repo.outcome }}
          VALIDATE_REPO_ERROR: ${{ steps.validate_repo.outputs.error_message || '' }}
          CREATE_JIRA_OUTCOME: ${{ steps.create_jira.outcome }}

      - name: Prepare Zoom notification payload
        id: prepare_zoom
        if: steps.validate_url.outcome == 'success' && steps.validate_repo.outcome == 'success'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const title = process.env.TITLE;
            const jiraUrl = process.env.JIRA_URL;
            const issueUrl = context.payload.issue.html_url;

            const payload = {
              "Extension": title,
              "Jira Ticket": jiraUrl || '❌ Not created',
              "Issue": issueUrl
            };

            // Base64 encode to prevent GitHub from masking the output
            const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64');
            core.setOutput('payload', encodedPayload);
        env:
          TITLE: ${{ needs.extract-issue-details.outputs.title }}
          JIRA_URL: ${{ steps.create_jira.outputs.jira_url }}

  submit-update:
    needs: extract-issue-details
    if: |
      always() &&
      contains(github.event.issue.body, 'template:02-submit-update')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      zoom_payload: ${{ steps.prepare_zoom.outputs.payload }}
      template_key: ${{ steps.prepare_comment.outputs.template_key }}
      error_message: ${{ steps.prepare_comment.outputs.error_message }}
      should_close: ${{ steps.prepare_comment.outputs.should_close }}
      has_comment: ${{ steps.prepare_comment.outputs.has_comment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate pull request URL
        id: validate_pr
        if: needs.extract-issue-details.outputs.error_message == ''
        continue-on-error: true
        run: |
          python3 .github/scripts/validate_repo_url.py "${{ needs.extract-issue-details.outputs.url }}"

      - name: Prepare Zoom notification payload
        id: prepare_zoom
        if: steps.validate_pr.outcome == 'success'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const title = process.env.TITLE;
            const prUrl = process.env.URL;
            const versionNumber = process.env.VERSION_NUMBER;
            const issueUrl = context.payload.issue.html_url;

            const payload = {
              "Extension": title,
              "Version": versionNumber,
              "PR": prUrl,
              "Issue": issueUrl,
              "Action": "⚠️ Create associated update ticket."
            };

            // Base64 encode to prevent GitHub from masking the output
            const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64');
            core.setOutput('payload', encodedPayload);
        env:
          URL: ${{ needs.extract-issue-details.outputs.url }}
          VERSION_NUMBER: ${{ needs.extract-issue-details.outputs.version_number }}
          TITLE: ${{ needs.extract-issue-details.outputs.title }}

      - name: Prepare comment data
        id: prepare_comment
        if: always()
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const extractError = process.env.EXTRACT_ERROR || '';
            const validateError = process.env.VALIDATE_ERROR || '';

            // Job is successful if there are no errors
            const jobSuccess = !extractError && !validateError;

            let templateKey;
            let errorMessage = '';
            let shouldClose = false;

            if (jobSuccess) {
              templateKey = 'update-submission.success';
            } else {
              const specificError = extractError || validateError;
              templateKey = specificError
                ? 'update-submission.failure-specific'
                : 'update-submission.failure-generic';
              errorMessage = specificError || '';
              shouldClose = true;
            }

            core.info(`Template key: ${templateKey}`);
            core.info(`Error message: ${errorMessage}`);
            core.info(`Should close: ${shouldClose}`);

            core.setOutput('template_key', templateKey);
            core.setOutput('error_message', errorMessage);
            core.setOutput('should_close', shouldClose.toString());
            core.setOutput('has_comment', 'true');
        env:
          EXTRACT_ERROR: ${{ needs.extract-issue-details.outputs.error_message }}
          VALIDATE_ERROR: ${{ steps.validate_pr.outputs.error_message }}

  post-comment:
    needs: [extract-issue-details, submit-extension, submit-update]
    if: |
      always() &&
      (needs.submit-extension.outputs.has_comment == 'true' ||
       needs.submit-update.outputs.has_comment == 'true')
    uses: ./.github/workflows/common-post-issue-comment.yml
    with:
      issue_number: ${{ github.event.issue.number }}
      template_key: ${{ needs.submit-extension.outputs.template_key || needs.submit-update.outputs.template_key }}
      error_message: ${{ needs.submit-extension.outputs.error_message || needs.submit-update.outputs.error_message }}

  close-issue:
    needs: [extract-issue-details, submit-extension, submit-update, post-comment]
    if: |
      always() &&
      needs.post-comment.result == 'success' &&
      (needs.submit-extension.outputs.should_close == 'true' ||
       needs.submit-update.outputs.should_close == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Close issue
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed',
              state_reason: 'not_planned'
            });

  notify-zoom:
    needs: [extract-issue-details, submit-extension, submit-update]
    if: |
      always() &&
      (needs.submit-extension.outputs.zoom_payload != '' ||
       needs.submit-update.outputs.zoom_payload != '')
    uses: ./.github/workflows/common-notify-zoom.yml
    with:
      payload: ${{ needs.submit-extension.outputs.zoom_payload || needs.submit-update.outputs.zoom_payload }}
    secrets:
      ZOOM_WEBHOOK_URL: ${{ secrets.ZOOM_WEBHOOK_URL }}
      ZOOM_VERIFICATION_TOKEN: ${{ secrets.ZOOM_VERIFICATION_TOKEN }}
